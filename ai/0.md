# ブロックテキストの字句解析用ライブラリを作成したい

Unicodeテキストから文書構造を持った書式「ブロックテキスト」を字句解析するJavaScriptライブラリ`Blot`を作りたい。

`Blot`は`Block`と`Text`を合わせた造語。`manuscript`は特定の書式に従い文書構造を表したUTF8データである。このデータ量は10万字を超える規模も想定する。ブラウザがメモリ不足やフリーズしないよう工夫が必要。

```js
export class Blot {
    constructor(manuscript) {}
    get manuscript() {return this._.manuscript}
    lex() {// 字句解析
        const blocks = [];
        // 書式に応じて blocks.push(new Block/FenceBlock(...)) する
        return blocks;
    }
    *lexGen() {// 字句解析。一ブロックずつ返す。フリーズ対策だが、結局はシングルスレッドである限りフリーズ不可避か。消費メモリはどうか。意見を求む。
        yield block;
    }
    async lexAsync() {// 字句解析。一ブロックずつawait(0)を挟む。フリーズ対策だが、結局はシングルスレッドである限り総合時間はlex()より余計に長くなってしまうか。消費メモリも増えそう。でも見た目上のフリーズは回避できそう。この認識で合っているか。意見を求む。
        block;
    }
}
```

字句解析したら以下内部データ構造のインスタンスを生成する。

```js
class Block {
    constructor(type, param={}, index=[0,0]) {}
    get type() {return this._.type}
    get param() {return this._.param}
    get index() {return this._.index}
}
class BlockType {static valid(){}}
class BlockParam {static valid(){}}
class BlockIndex {static valid(){}} // [start, end] 0から始まる start<end
```

ブロック要素の種別毎に具体化して使うことになるかな？

```js
class HeadingBlock extends Block {}
class ParagraphBlock extends Block {}
class SceneChangeBlock extends Block {}
class PagingBlock extends Block {}
```

フェンスブロックは多種多様で複雑だから文脈の特定用クラスが必要かも？

```js
class FenceContext {
    static get(fenceStartParamText, fenceEndParamText) {
        // フェンス記号とそこから続く文字列を元に必要な情報を抽出する
        return {context:context, param:param, char:char, num:num}; // フェンス種別、引数、記号、記号数
    }
}
```
```js
class FenceBlock extends Block {
    constructor(context, param={}, index=[0,0]) {
        super('fence', param, index);
        this._ = FenceContext.get(param);
    }
}
```

ブロックには型や引数がある（後述）。ブロックは原稿のstring上におけるindexの開始と終了の位置を保持する。これにて原稿`manuscript`の部分文字列を取得することでその内容を取得できるものとする。

`Jaml`は`Blot`の呼出元である。原稿をHTMLテキストに変換するパーサ。`Japanese Markup Language`の略。今回は守備範囲外と考えて良いが、Blotの出力形式を考える上で想定しておいたほうが良い。

```js
class Jaml {
    parse(manuscript) {
        const htmls = [];
        const blot = new Blot(Manuscript.normalize(manuscript));
        for (let block of blot.lex()) {
            const inText = blot.manuscript.slice(...block.index);
            // フェンスブロックなら更にブロック解析が必要。
            // 他のブロックはブロック解析完了。次はそれぞれのブロック種別に応じた処理をする。
            // インライン要素をHTML化する処理をする。
            // 最後にブロック要素自体のHTML化をする。
        }
        return htmls.join('\n'); // manuscript全体のHTMLテキストを返す
    }
    parseAsync(manuscript) {
        for (let block of blot.lex()) {
            await(0); // フリーズ対策
            return ブロック単位のHTMLテキストを返す;
        }
    }
}
```

ここで`inText`が想定通りの文字列を取得できれば本案件の目的は達成である。

つまり本案件は`Blot.lex()`というブロックを抽出する字句解析が主要な仕事になる。ただ、そのブロックの単位や構造をどのように定義するかを、よく考えねばならない。そのためには将来実装しそうな詳細仕様をぼんやりイメージしておく必要がある。よってこれ以降は、`Blot`担当外の周辺仕様についてのイメージを語る。

## テキスト問題

原稿は正規化する。この正規化は、セキュリティ、Unicodeの正規化、日本語の正規化、OS毎に異なる改行の正規化、Jaml構造の観点から行われる。

大雑把なコードは以下。

```js
class Manuscript {
    static normalize(text) {
        // normalize('NFC') は CJK統合漢字を見た目が異なる字に変えてしまうため CJK統合漢字 を除外して行いたいが、そんなことは可能か？
        return text.normalize('NFC').replace(/\r|\r\n/g, '\n').replace(/\0/g, '');
    }
}
```

考慮すべき観点は以下。

* セキュリティ
    * サニタイズ
        * 使わないUnicodeの制御コードを削除する
            * U+0000を削除してヌルバイト攻撃不可能にする等（但しフェンスブロック内ではエスケープシーケンスを使う文脈もありえるためブロックごとに処理を変える必要がある。そもそも使わない制御コードを指定するには国や言語、文書構造など様々な観点から指示し、それに該当する全字を網羅する必要がある。Unicodeの全字を熟知している人間にしかできないため非現実的に思える。また処理の回数や量も多くなり実行速度の低下が予想される。費用対効果的に如何なものかという懸念もある。安全性と応答性のトレードオフか。）
* Unicodeの正規化: `text.normalize('NFC')`
    * `normalize('NFC')`は CJK統合漢字 を見た目が異なる字に変えてしまうため CJK統合漢字 を除外して行いたいが、そんなことは可能か？
    * Unicodeには同じ字を別々のバイナリで表現できてしまう。これによりテキスト検索で同じ字なのにヒットしない事態が起きる。こうした問題を解消するための処理。例えば以下。
        * `か`と濁点結合文字`U+309A`の結合文字`U+304B,U+3099`を統合文字`U+304C`に変換する
* 日本語の正規化: (Unicodeの正規化NFC等では不可能な正規化)
    * 濁点記号→統合文字または濁点結合（統合文字があれば統合文字、なければ結合文字にする）
        * `か`と濁点記号`゛`の二文字`U+304B,U+309B`を統合文字`U+304C`に変換する
        * `あ`と濁点記号`゛`の二文字`U+3042,U+309B`を結合文字`U+3042,U+3099`に変換する
    * 半濁点記号→統合文字または濁点結合（統合文字があれば統合文字、なければ結合文字にする）
        * `は`と半濁点記号`゜`の二文字`U+306F,U+309C`を統合文字`U+3071`に変換する
        * `あ`と半濁点記号`゜`の二文字`U+3042,U+309C`を結合文字`U+3042,U+309A`に変換する
    * 部首など見た目が同じだが異なるコードポイントを持つ字の対処
        * ユーザ設定次第で、削除、置換（正規化？）、例外発生、無視（そのまま）、のように対処する
* OS毎に異なる改行の正規化
    * Windowsは`CRLF`, 旧Macは`CR`を改行とするが、これを全て`LF`に統一したい
    * UnicodeにはLSという改行を意味するコードがあるが、これはJamlでは改行と認めず無視する
    * UnicodeにはPSという段落終端を意味するコードがあるが、これはJamlでは解釈せず無視する
* Jaml構造としての正規化
    * 上記以外でJamlでは禁止されたUnicodeの文字を除外する（ちょっと思いつかないけど構文毎に出てくるはず。原稿の処理でなく構文解析の時点でようやく処理が決まるものかもしれない）

これら原稿テキストへの処理は、一言でいうと「Unicodeのサニタイズ」だ。Unicodeは正常なデータであってもセキュリティ問題が膨大にあって酷い。ヌルバイト攻撃、不正なバイトシーケンス、正規化の問題（ホモグラフ攻撃）がある。これらはユーザの想定内なのか想定外なのか判断することが困難であったり、パターンが膨大すぎて非常識なほどのリソースが必要だったりして対処不能である。

Unicode問題を解決するには新しいテキスト・システムを一から作り上げる必要がある。だがそんなことはやってられないので、仕方なくUnicode問題に対して、少しだけ対処し多くの危険性を受け入れる、という決断をせざるを得ない。

今回はあくまで`Blot`ブロックテキストの字句解析がメインなので、Unicode問題など各種文脈から来るテキスト問題全般に対しては、なるだけ主要なものを全部ピックアップして対処する。現実的に不可能なものに関しては実装の対象外としてメモに書き残す。

できれば対象外としておきたいが、`Blot`の入力データとして関わるため、最低限の実装は必要だと思われる。

## ブロック構造

原稿においてブロックを分断する箇所は改行コードLFが二連続した箇所である。つまり改行コードLF二連続は`Blot`におけるメタ文字と言える。但しフェンスブロックは改行コードを単なるテキストデータとして扱い、ブロック分断はしない。

フェンスブロックはMarkdownのフェンスブロックと同じだ。行頭から3つ以上のバッククォートが連続した時にフェンスが開始され、同数のバッククォートで開始し終了する行がフェンスブロックの終端と解釈される。そしてバッククォートの数を増やすことで、内部にフェンスブロックをネストできる。これもMarkdownと同じだ。そして開始記号のすぐ隣には`javascript`など任意の文字列を付与できるものとする。これもMarkdownと同じだが、`Blot`ではもっと複雑化する予定だ。

`Blot`においてブロックと定義するものは以下の種類がある。（今後増える可能性はある）

1. 外部ファイル参照ブロック
2. フェンスブロック
3. ヘッディングブロック
4. パラグラフブロック
5. 部位分割ブロック

以下のような構造を想定している。

``````blot
---
title: この文書のタイトル
summary: |-
    文書の冒頭にフェンスブロックを書けば、フロントマターとして解釈される。
    フロントマターはYAML形式で文書のメタデータを書けるものとする。
lexer:
    hr:{
        default:{text:'■□', max:3, align:center},
        fin:{text:'完', max:1, align:end},
        other:{text:'{{text}}視点', max:1, align:start}}
---

part: part/jaml/manuscript/0.jaml

# 見出し

意味段落。
形式段落。

２つ目の意味段落。二文目。

=====

場面転換後の段落。

# 見出し

=====山田

山田視点のテキスト。

==========

強制改ページ直後の段落。

今回は実装対象外だが、インライン要素において以下のようなものを想定している。

｜漢字《ルビ》に《《強調》》。親文字が漢字《かんじ》ならパイプを省略できる。

｜親文字《うえ｜した》、｜テキスト《URL》、｜親文字《うえ｜した｜URL》、｜山田,太郎《やまだ,たろう｜タロー》、｜山田太郎《やま,だ,た,ろう｜タロー》など、リンク、グループルビ、熟語ルビ、モノルビまでカバーできる。

《《強調｜きょうちょう》》とすれば上に傍点、下にルビが出る。《《強調｜きょうちょう｜URL》》とすればリンク化できる。

=====fin
``````

### 1. 外部ファイル参照ブロック

```blot
part: manuscript/1.blot
```
```blot
part: img/icon/a.png
```

どういう構文にすべきかは考える余地がありそう。いずれにせよ文書が膨大になると保守性が下がるため複数ファイルに分離したい。あるいはテキストデータではなくバイナリデータであるため表現不能。理由はどうあれ外部ファイルを参照したい。

以下はまったく別のブロックとして定義すべきだとも思える。

* ブロックテキストを外部参照する
* 非ブロックテキストを外部参照する

とにかく外部参照するブロックは欲しいので、ここでそれを明記しておく。

### 2. フェンスブロック

最も価値があり最も複雑なブロック。

フェンスブロックはMarkdownのフェンスブロックと同じだ。行頭から3つ以上のバッククォートが連続した時にフェンスが開始され、同数のバッククォートで開始し終了する行がフェンスブロックの終端と解釈される。そしてバッククォートの数を増やすことで、内部にフェンスブロックをネストできる。開始記号のすぐ隣には`javascript`など任意の文字列を付与できる。`Blot`ではもう少し複雑化する予定だ。

フェンス記号|文字
------------|----
対象内|`` !"#$%&'-^~@+*`<>?/\ ``
対象外|`` ()=¥|[{;:]},. ``

記号|役割
----|----
`!`|注釈用ブロック（`⚠`などのアイコンを表示したり線で囲ったりして視覚的に注目させる領域。注意や補足用）
`"`|引用符（外部文書からの引用とそのURL指定）
`#`|コメントブロック（`Blot`が変換処理をしないブロック）
`$`|`<script>`に埋め込むJavaScriptソースコード記入ブロック。
`%`|`%some%`のような書式を置換するテンプレートブロック。
`&`|`<style>`に埋め込むCSSソースコード記入ブロック。
`'`|会話ブロック（チャット、掲示板など特定の会話を表記する）
`-`|非表示DB用ブロック（フロントマター、URLの短縮定義、`<template>`等、他から参照される想定のデータ）
`^`|注釈用データブロック（マウスオーバーなどで表示される注釈用テキストデータを定義する領域）
`~`|`<details><summary>`ブロック。チルダ`~`の意味が「約、およそ、〜から」であることから。
`@`|文書の著者や関係者への連絡先や文書のライセンスを定義するブロック。
`+`|異文脈表示用ブロック(データ構造(table, list, tree, network), ダイアグラム(mermaid), 操作(keybordmap), AA(ascii-art)、端末(ANSIエスケープシーケンス(をHTML表示する))等)
`*`|フォーム、エディタ、アプリなどユーザ入力で編集可能なインタラクティブ系の内容を書くブロック。
`` ` ``|ソースコード構文強調ブロック。しばしば言語名やファイル名などの引数がある。コピーやDLボタンが欲しい。
`<`|`Blot`など解析ツールへのテキスト解析用設定値を定義するブロック。
`>`|`Blot`など解析ツールへのテキスト出力用設定値を定義するブロック。
`?`|注釈用ブロック（`❓`などのアイコンを表示したり線で囲ったりして視覚的に注目させる領域。ヘルプ用。）
`/`|非表示DB用ブロック（参照パス短縮定義用）：内部文書のパス短縮定義、URLの短縮定義
`\`|エスケープブロック（原稿そのままのテキストで出力するブロック。`Blot`メタ文字もそのまま出力する）。

記号|使わない理由
----|------------
`=`|ページ分割位置を指定するメタ文字として使う（5連続で水平線、10連続でページ分割）
`(`|インライン用メタ文字に使いそうだから
`)`|インライン用メタ文字に使いそうだから
`¥`|日本語環境でしか出なそうだから
`|`|インライン用メタ文字に使いそうだから
`[`|インライン用メタ文字に使いそうだから
`{`|インライン用メタ文字に使いそうだから
`;`|インライン用メタ文字に使いそうだから
`:`|インライン用メタ文字に使いそうだから
`]`|インライン用メタ文字に使いそうだから
`}`|インライン用メタ文字に使いそうだから
`,`|インライン用メタ文字に使いそうだから
`.`|インライン用メタ文字に使いそうだから

``````blot
!!!
フェンスブロック（エクスクラメーション形）
注釈内容（注意書き、または補足。補足は別にしたほうが良いか？）
!!!
"""
フェンスブロック（ダブルクォート形）
外部文書からの引用とそのURL指定
"""
###
フェンスブロック（シャープ形）
コメントブロック
###
$$$
// フェンスブロック（ダラー形）
console.log('Hello JavaScript !!');
$$$
%%%
フェンスブロック（パーセント形）
key1: これに置換する 
key2: コレに置換する 
%%%
&&&
フェンスブロック（アンパサンド形）
p {font-color:red;}
&&&
'''
フェンスブロック（シングルクォート形）
A:山田,B:鈴木,split=LF1
A	やあ
B	こんにちは
A	元気？
B	さようなら

0:山田,1:鈴木
やあ
こんにちは
元気？
さようなら

A:山田,B:鈴木,split=LF2
やあ
元気？

あんた誰？

俺だよ俺
ほらあのあれだよ

知らない。さよなら
'''
---
フェンスブロック（マイナス形）
1	https://www.google.co.jp/
2	https://www.yahoo.co.jp/
---
^^^
フェンスブロック（キャレット形）
1	マウスオーバーなどでポップアップ表示される注釈
2	マウスオーバーなどでポップアップ表示される注釈
^^^
~~~summaryの内容
フェンスブロック（チルダ形）
detailsの内容
~~~
@@@
フェンスブロック（アットマーク形）
人名1	URL
人名2	URL
licenseID（cc0, cc-by, mit等）
@@@
+++table tsv head=row1
名前	年齢
山田	12
鈴木	24
高橋	36
+++
***form
username [    ]
password [    ]
[submit]
***
```some.js
console.log('Hello JavaScript !!');
```
<<<
フェンスブロック（レッサー形）
someParam.key = X;
<<<
>>>
フェンスブロック（グレーター形）
someParam.key = X;
>>>
???
フェンスブロック（クエスチョンマーク形）
???
///
path1	/some/dir/1.txt
///
\\\\\\
# エスケープブロック

どんなメタ文字でもそのまま出力する。

---
ブロック構文もエスケープできる。
---
\\\
エスケープブロック自体もエスケープ可能。
\\\
\\\\\\
``````

### 3. ヘッディングブロック

見出しを宣言する。

```blot
# 見出し1

## 見出し2
```
```html
<h1>見出し1</h1>
<h2>見出し1</h2>
```

見出しグループで副題も宣言する。副題はインデントしても良し。HTML出力時、両端の空白文字は削除される。主題と副題を一行で表示するか二行で表示するかは、どうやって定義しよう？　

```blot
# 見出し1
副題1
```
```html
<hgroup>
  <h1>見出し1</h1>
  <p>副題1</p>
</hgroup>
```

以下の場合は主題と副題を一行で表示する。

```blot
# 見出し1: 副題1
```
```html
<hgroup>
  <h1>見出し1</h1>
  <p style="display:inline;">副題1</p>
</hgroup>
```

よくある一般的な文書構造は以下。

```blot
# 見出し1
    副題1

## 見出し2

本文。
```
```html
<hgroup>
  <h1>見出し1</h1>
  <p>副題1</p>
</hgroup>
<h2>見出し2</h2>
<p>本文。</p>
```

アンカー用IDカスタム作成。標準では`#1-1`のように自動作成される。

```blot
# 見出し1 {#slug}
副題1
```
```html
<hgroup>
  <h1 id="slug">見出し1</h1>
  <p>副題1</p>
</hgroup>
```

### 4. パラグラフブロック

```blot
意味段落。
形式段落。

２つ目の段落。
```
```html
<p>意味段落。<br>形式段落。</p>
<p>２つ目の段落。</p>
```

3連続以上改行コードLFがあった場合は？　以下のような解釈の仕方がある。

* 文書構造における意味論的には無視すべき
* 空行を表示して欲しい

もし空行を表示するなら以下のようになる。`<p>`で既に1個分の改行は表現できるから、`3個以上連続改行-1個`だけ`<br>`を入れたら良い。

```html
<p></p>
<p><br></p>
<p><br><br></p>
```

ところで空行を表示したいのはなぜ？　それは文書構造的に、どういう意味？　これを定義しないと段落でない余白に対して段落と意味づけた、間違ったマークアップになってしまう。

じゃあ以下のようにWebComponentを実装すれば良い？　それも違う。

```html
<blank-line></blank-line>
```

そもそもHTMLは文書の構造を意味付ける構文だ。よってこの空行が文書構造において何を意味するものか定義する必要がある。

以下二つの解釈がある。

* 余白
* ページ分割

前者の余白は人間の視認用である。字がギチギチに詰まっていると読む気がなくなる。なので余白として改行を入れる。これはヒューリスティック判断による入力のため、機械的に判断することは不可能だ。

後者のページ分割は、文書内容を意味論的に区切るべく設定する物理余白である。たとえば章や節の終わりを示す時など。基本的に見出し箇所から本文開始までの間でページを区切るか否か判断できるため、あえて空行で指定する必要はないように思える。

となると3連続以上改行は、段落の末尾に付与する改行ということになる。しかし、タイポにより一つ多く入力しただけかもしれない。これはユーザの設定により入力是非を決定することにすべきだろう。基本的には3個以上連続改行は2連続改行と解釈して良い。その時は次のようにdata属性値に記録しておけば、後で対応しやすい。

```html
<p data-head-new-line-num="2" data-tail-new-line-num="5">(設定次第でここにbr要素が2個入る)本文。(設定次第でここにbr要素が5個入る)</p>
```

## ページ（Blot担当外）

文書にはページという概念が存在する。ページは物理的な分割単位だ。しかしHTMLはテキスト内容の意味論的な分割単位しか存在しない。よって意味論的なマークアップをするタグとは区別したマークアップが必要である。

ページとは、印刷する紙面の制限とか、表示する画面の制限によって定まる分割単位である。

`Blot`においては担当範囲外だ。もっと上位の所で、どうにかすべきことだろう。つまりブロックとしては「ページ分割ブロック」という内容で保持しておくべきである。

もしページという概念でHTMLをマークアップするなら`<div style="break-after:page;">一ページ内に表示するHTMLコンテンツ</div>`という単位でまとめることになるだろう。しかしこれはページや内容の表示サイズを取得せねばならず、かなり時間のかかる処理になりそうだ。もちろん`Blot`の責任範囲外であり今回は実装しなくて良い。ただ、将来はページ分割箇所を強制する部分を示す書式が必要である、ということだけは理解しておくべきだ。

たとえば以下のように、どうページングするかをユーザが設定する必要があるだろう。

* 見出しブロックと段落ブロックの間でページ分割する（見出しだけのページ（扉ページ）を作る）
* 見出しブロックの先頭でページ分割する（ページの冒頭が必ず見出しブロックになる）

こうしたページングは将来、別の機能として実装することになる。

`Blot`として気にすべきは、「ここで強制的にページ分割する」という役割のブロック要素を用意しなくても良いか否かだ。私としては不要だと思っている。仮に必要だとしても`Block.type='paging'`のようなブロックを用意すれば良いだろう。現行の書式は`=`を10連続書くことで定義できるようにするとかで良いだろう。

## 5. 部位分割ブロック

`Blot`|HTML
------|----
`=====`|水平線`<hr>`
`==========`|ページ強制分割（`<div style="break-after:page;">一ページ内に表示するHTMLコンテンツ</div>`等）

水平線はMarkdown同様`---`のほうが良いとも思ったが、フェンスブロックで使用している。どちらもレアケースのため、どちらにどの字を割り当てるか判断に苦慮する。

`-`と`=`で明確に役割を分けたほうが良い。`-`はフェンスブロック定義にし、`=`はページ分割を意識した役割を割り当てるようにする。

ちなみに水平線は、フロントマターにて、任意のテキストを表示するよう設定できることとする。

``````blot
---
lexer:
    hr:{
        default:{text:'■□', max:3, align:center},
        fin:{text:'完', max:1, align:end},
        other:{text:'{{text}}視点', max:1, align:start}}
---
``````

あるいは本文内で以下のように設定できる。一度セットしたら以降はずっとそれを使う。途中で`clear`すると初期値に戻る。

```jaml
=====■□■□■□
```
```jaml
=====clear
```

## まとめ

かなり荒い草案ですが、`Blot`クラスの要件や仕様の定義と実装について、順を追って一つずつ丁寧にお願いできますか？

多分MarkdownパーサのLexer部分を抽出したようなものが叩き台になるようなイメージです。

